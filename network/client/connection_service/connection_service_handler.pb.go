// Code generated by protoc-gen-go-bnet. DO NOT EDIT.

package connection_service

import (
	"context"
	"fmt"
	"strings"
	"google.golang.org/protobuf/proto"
)

// ConnectionServiceHandler is the handler interface for bgs.protocol.connection.v1.ConnectionService
type ConnectionServiceHandler struct {
	serviceHash uint32
	service     ConnectionService
}

// NewConnectionServiceHandler creates a new ConnectionServiceHandler
func NewConnectionServiceHandler(service ConnectionService) *ConnectionServiceHandler {
	return &ConnectionServiceHandler{
		serviceHash: ConnectionServiceOriginalFullyQualifiedDescriptorNameHash,
		service:     service,
	}
}

// GetServiceHash returns the service hash
func (h *ConnectionServiceHandler) GetServiceHash() uint32 {
	return h.serviceHash
}

// GetServiceFullName returns the service
func (h *ConnectionServiceHandler) GetServiceFullName() string {
	return ConnectionServiceOriginalFullyQualifiedDescriptorName
}

// GetServiceFullName returns the service
func (h *ConnectionServiceHandler) GetServiceName() string {
	return ConnectionServiceOriginalFullyQualifiedDescriptorName[strings.LastIndex(ConnectionServiceOriginalFullyQualifiedDescriptorName, ".")+1:]
}

// GetService returns the service
func (h *ConnectionServiceHandler) GetService() ConnectionService {
	return h.service
}

// Call calls the service by hash and method id on the handlers service
func (h *ConnectionServiceHandler) Call(ctx context.Context, methodId uint32, body []byte, conn interface{}) error {
	switch methodId {
	case 1:
		var req ConnectRequest
		if err := proto.Unmarshal(body, &req); err != nil {
			return err
		}
		return h.service.Connect(ctx, &req, conn)
	case 2:
		var req BindRequest
		if err := proto.Unmarshal(body, &req); err != nil {
			return err
		}
		return h.service.Bind(ctx, &req, conn)
	case 3:
		var req EchoRequest
		if err := proto.Unmarshal(body, &req); err != nil {
			return err
		}
		return h.service.Echo(ctx, &req, conn)
	case 4:
		var req DisconnectNotification
		if err := proto.Unmarshal(body, &req); err != nil {
			return err
		}
		return h.service.ForceDisconnect(ctx, &req, conn)
	case 5:
		return h.service.KeepAlive(ctx, nil, conn)
	case 6:
		return h.service.Encrypt(ctx, nil, conn)
	case 7:
		var req DisconnectRequest
		if err := proto.Unmarshal(body, &req); err != nil {
			return err
		}
		return h.service.RequestDisconnect(ctx, &req, conn)
	default:
		return fmt.Errorf("unknown method id %d", methodId)
	}
}
